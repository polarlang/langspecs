# 唯一定义原则

1. 任何一个转换单元里面的任何变量，函数，类类型，枚举类型和模板类型都只能存在一个定义。
2. 除了不求值操作数（unevaluated operand）和子表达式之外的表达式都是可能求值（potentially evaluated）的表达式。一个表达式`expr`可能的结果 *`potential results`* 定义如下：
	1. 如果`expr`是一个`id-expression`，那么值的集合只包含`expr`本身。
	2. 如果`expr`是一个数组操作数下标操作表达式，那么值的集合包含数组操作数可能的值。
	3. 如果`expr`是一个类成员访问表达式，那么值的集合包含对象成员访问表达式所有可能的值。
	4. 如果`expr`是一个指向类成员的指针并且第二个操作室是一个常量表达式，那么值的集合是对象成员访问表达式所有可能的值。
	5. 如果`expr`是一个形式为`(expr1)`的表达式，那么值的集合为`expr1`的值。
	6. 如果`expr`是一个`gvalue`值类型的条件表达式[*例如：`condexpr ? true-expr: false-expr;`*]，那么值的集合是第二个操作数和第三个操作数的值的联合。
	7. 如果`expr`是一个逗号表达式，那么值的集合是最右边操作数的值。
	8. 其他情况下，值集合为空。
	
	```cpp
	// 下面的例子中，n 的初始化表达式的结果是第一个 S::x 不是第二个 S::x
	struct S
	{
      static const int x = 0;
	};
	const int &f(const int &r);
	int n = b ? (1, S::x) // 这里 S::x 没有应用单一定义原则
	          : f(S::x) // 这里应用了单一定义原则，所以在这里需要看见 S 的完整定义
	```
3. 在如下情况下一个函数被一个表达式选择：
	1. 在一个表达式里面的函数会被当前的表达式选择，如果这个名字是通过唯一性查找的结果，或者在一个函数重载集合选择匹配的原型得到的。除非，这当前函数是一个纯虚函数并且他的名字没有显式的指定受限的名字或者当前的表达式是一个指向成员的指针。[*Note*：这里涉及了下面这几个概念：**获取函数的地址**，**使用函数名进行函数调用**，**运算符重载**，**用户自定义类型转换**，**在指定地址上分配内存的表达式`placement new-expressions`**和**非默认初始化**。 自定义类型在复制和移动的时候对构造函数的选择，也是一种函数被表达式选择的情况，只不过通常这种情况往往被编译器优化掉了。]
	2. 一个类的分配函数和释放被`new-expression`表达式所选择。
	3. 一个类的释放函数被`delete expression`表达式所选择。
4. 一个在可能求值的表达式`expr`中的变量`x`会被检查唯一性定义，除非对`x`做一次左值到右值的类型转换得到一个常量表达式，并且在转换过程中没有调用任何非平凡的函数。并且如果`x`是一个对象，`expr`是表达式`expr1`的可能的值的一个元素，`expr1`是进行一次左值到右值的转换，或者`expr1`是一个丢弃结果的表达式。
5. 结构化绑定如果出现在可能求值表达式里面，那么将进行唯一性定义检查。
6. 如果表达式`*this`出现在可能求值表达式里面，那么将进行唯一性定义检查。（包含非静态成员函数体中的隐式转换结果）
7. 一个虚拟函数如果不是纯虚函数，那么将进行唯一性定义检查，一个被可能求值表达是选择的函数原型，将进行唯一性定义检查。一个非指定地址的分配或者释放函数，将在一个类的构造函数的函数体中进行唯一性定义检查。一个非指定地址的释放函数，将在当前类的析构函数或者当前查找选择的虚析构函数的函数体中进行唯一性定义检查。
8. 复制运算符函数，构造函数，析构函数的唯一性定义检查 （todo：有待完成）
9. 如果满足如下条件，一个局部的程序实体也将进行唯一性定义检查：
	