# 内存和对象
## 内存模型
1. 在极语言的内存模型中最基础的存储单元是字节`byte`。一个`byte`的大小至少要能容纳任何在执行字符集里面的字符成员和UTF8编码规范的八比特的编码单元并且由连续的比特序列组成，比特序列的长度由极语言编译器决定。最不重要的比特（`least significant bit`）叫做`low-order bit`；最重要的比特叫做`high-order bit`，系统提供给极语言的内存是由一个或者多个字节序列组成的。没有个字节都有一个唯一的地址。
2. 一个内存位置是一个标量类型的对象或者由相邻的长度不为零的比特位域的最长序列。[*Note: 语言的各种特性，比如引用或者虚函数，可能使用一些程序员不可见但是由编译器进行管理的内存位置。*]两个或者多个运行的线程同时访问不同的内存位置不会相互干扰。
3. [*Note: 一个位域和其相邻的非位域字段是在不同的内存位置，因此可以被两个或者多个线程同时访问而不会相互干扰。这个规则对两个位域其中一个定义在嵌套的结构体而另一个不是的情况或者两个位域之间被长度为零的位域隔开，或者被不是位域的字段隔开。同时更新结构体中两个中间都是长度不为零的位域是不安全的。*]
	
	例子说明
	
	```cpp
	struct 
	{
	  char a;
	  int b: 5,
	  c: 11,
	  :0,
	  d: 8,
	  strcut { int ee: 8} e;
	}
	```
	以上代码含有四个内存位置成员a，位域d，位域e.ee是不同的内存位置，可以同时进行修改而不会相互影响。位域b和位域c是第四个内存位置，它两不能同时进行修改，但是成员a和位域b可以同时进行修改。

## 对象模型

1. 在极语言中对对象有创建，销毁，引用，访问和操作等活动。对象的创建按照定义，通过`new-expression`创建，当隐式的改变联合体当前活动成员的时候或者当一个临时对象被创建。在对象被创建到其整个生命周期，直到最后被销毁，占用一段区域的存储空间。[*Note: 函数不是对象，尽管可能函数也会像对象那样占用一定的存储空间。*][*todo: 函数不是`first class`类型？*]对象的属性在对象创建之后进行检查。一个对象可以有名字。一个对象可以有存储周期，并会影响对象的生命周期。一个对象具有类型。一些对象是多态的，由编译器负责生成一些跟这些多态类相关的信息，在运行时能够判断对象的类型。对于其他类型的对象的值，通过访问它的`expressions`的类型来决定。
2. 对象可以包含其他的对象，叫做子对象`subobjects`。一个子对象可以是成员子对象（`member subobject`），也可以是基类子对象（`base class subobject`）或者一个数组的元素子对象。一个不是其他任何对象的子对象的对象称作一个完整的对象（`complete object`）。一个对象在成员对象或者数组元素`e`所在的存储区域创建的时候，新创建的对象是`e`的所属对象的子对象的话，需要同属满足下面的条件：
	1. `e`的宿主对象的作用域已经开始，但是还没有结束。
	2. 新创建的对象的存储空间正好覆盖了`e`所关联的存储空间。
	3. 新创建的对象的类型跟`e`的类型一样。(忽略cv-qualification）
	
	[*Note: 如果新的子对象中包含有引用成员或者常量子对象成员，原来对象的名字不能用来访问新创建的对象。*]
	
	例子说明：
	
	```cpp
	class X
	{
	   const int n;
	};
	
	union U
	{
	   X x;
	   float f;
	};
	
	void tong()
	{
	   U u = {{ 1 }};
	   u.f = 5.0f; // OK 创建一个 u 的子对象
	   X *p = new (&u.x) X {2}; // OK 创建一个 u 的子对象
	   assert(p->n == 2); // OK
	   assert(*polar::lanuder(&u.x.n) == 2); // OK
	   assert(u.x.n == 2); // 为定义行为，不能通过 u.x 对创建的新对象进行访问
	}
	```
3. 如果一个完整的对象在一个类型`e`为`array of N unsigned char`的对象或者为`array of N polar::byte`的对象所关联的对象上创建，当同时满足下面的条件时数组将为新创建的对象提供存储空间：
	1. `e`的生命周期已经开始并且还没有结束。
	2. 新创建的对象的存储空间符合`e`所关联的存储空间的大小。
	3. 没有更小的数组对象满足这些限制。
	[*Note: 如果数组的存储空间被一个对象占用，那么那个对象的生命周期结束，因为它的存储空间被重新使用了。*]
	
	例子说明：
	
	```cpp
	template<typename ...T>
	struct AlignedUnion
	{
	   alignas(T...) unsigned char data[max(sizeof(T)...)];
	};
	
	int f()
	{
	   AlignedUnion<int, char> au;
	   int *p = new (au.data) int; // OK, au.data provides storage
	   char *c = new (au.data) char(); // OK, ends lifetime of *p
	   char *d = new (au.data + 1) char();
	   return *c + *d; // OK
	}
	
	struct A { unsigned char a[32]; };
	struct B { unsigned char b[16]; };
	A a;
	B *b = new (a.a + 8) B; // a.a 提供存储空间给 *b
	int *p = new (b->b + 4) int; // b->b 提供存储空间给 *p
	                             // a.a 没有直接提供存储空间给 *p
	                             // 但是 *p 嵌套在 a 中
	```
4. 当满足下面任何一条时候，我们就说对象`a`嵌套在（`nested within`）对象`b`中：
	1. 对象`a`是对象`b`的子对象。
	2. 对象`b`给对象`a`提供存储空间。
	3. 存在一个对象`c`，对象`a`嵌套在对象`c`里面，对象`c`嵌套在对象`a`里面。
5. 对于任何对象`x`，都存在某个对象叫做对象`x`的完整对象。判断条件如下：
	1. 如果`x`是完整对象，那么`x`的完整对象是它自己。
	2. 否则，`x`的完整对象是唯一包含对象`x`的完整对象。
6. 如果一个完整对象，一个数据成员或者一个数组元素是一个类类型，他们的类型被称作`most derived class`，用来这个类类型与其基类的子对象。一个`most derived class`或者非类类型的对象叫做`most derived object`。
7. 除非是位域，一个`most derived object`应该占用一个或者多个字节的存储空间。基类子对象可能不占用存储空间。一个含有平凡复制能力（`trivially copyable`）或者标准内存布局（`standard-layout`）类型的对象应该占用连续的字节序列的存储空间。
8. 除非是位域或者是大小为零的基类子对象，对象的地址是其占用的存储空间的首字节的地址。一个生命周期相互覆盖的两个非位域的两个对象，如果一个嵌套在另一个里面或者至少一个是大小为零的基类子对象并且两个对象的类型不一样，这两个对象的地址可能一样，否则他们具有不同的地址。
	
	例子说明：
	
	```cpp
	static const char test1 = ’x’;
	static const char test2 = ’x’;
	const bool b = &test1 != &test2; // 永远为 true
	```
9. [*Note: 极语言提供一些最基本的类型定义和几种从现有基础类型合成新类型的机制。*]

## 对象生命周期

1. 对象或者引用的生命周期是对象或者引用的运行时属性。一个对象如果是一个类类型或者聚合类型并且它自己或者它的一个子对象被一个非平凡的构造函数初始化，那么我们说这个对象具备有意义的初始化（`non-vacuous initialization`）[*Note: 被平凡的复制或者移动构造函数初始化也是一个具备意义的初始化。*]，当下面的条件全部满足的时候，类型`T`的对象的生命周期开始：
	1. `T`的存储空间被合理的进行了对齐并且类型`T`的大小已经被获取。
	2. 如果`T`的对象具有有意义的初始化，它的初始化已经完成。
	除了下面这种情况，如果对象是一个联合体的成员或者子对象，它的生命周期只有当前在联合体中已经初始化完成之后才开始。
2. 当下面的情况中一种发生时，对象的作用域结束：
	1. 如果类型`T`是一个具有非平凡的析构函数的类类型，它的析构函数开始调用。
	2. 对象占用的存储空间被释放或者被一个不是对象`o`的嵌套对象所占用。
3. 一个引用的生命周期开始于他被初始化，然后跟标量数据类型的对象一样的方式结束。
4. 在本文档中归于对象或者引用的属性只在其声明周期里面进行应用。[*Note: 在一个对象的声明周期开始之前或者结束之后去使用一个对象的时候需要特别注意，同样的一个正在构造中的对象和一个正在被析构的对象的使用也跟正在生命周期已经开始且没有结束中的对象有很大的区别。*]
5. 一个程序可能通过重新利用一个对象的存储空间的方式来终止任何一个对象的生命周期或者通过调用一个类类型的非平凡的析构函数来终止。对应一个具有非平凡的构造函数的类类型，当它所占用的存储空间被重新利用或者被释放，不要求程序显式的对其析构函数进行调用。然后如果一个程序没有显示的调用析构函数或者没有用`delete-expression`去释放占用的空间，析构函数不能隐式的被调用并且任何依赖析构函数副作用的行为都是未定义的。
6. 在对象的生命周期开始之前但是在对象的存储空间已经被分配之后，或者在对象的生命周期结束之后但是在对象占用的存储空间被回收或者重新利用之前，这个时候指向对象所占用的存储空间的指针只能以受限的方式进行使用。当对象正在构造或者析构的时候，指向对象分配的存储区域的指针的类型是`void *`，是被很好的定义了。通过这样的指针间接访问存储区域是可以的，但是如果形成一个左值的话，只能按照受限的方式进行使用。如果下面任何一条满足，程序都是未定义的：
	1. 对象有一个非平凡的析构函数，这个指针被用在了`delete-expression`表达式中。
	2. 指针用来访问非静态数据成员或者非静态函数成员。
	3. 指针隐式的转换成指向虚拟基类的指针类型。
	4. 除了后面的转换类型，转换成`cv void`类型或者指向`cv void`类型的指针并且随后变成指向`cv char`或者`cv unsigned char`或者`cv std::byte`类型的指针。
	5. 指针被用在了转换操作符`dynamic_cast`的操作数：
		
		例子说明：
		
		```cpp
		import cstdlib;
		
		class B
		{
		   virtual void f();
		   void mutable();
		   virtual ~B();
		};
		
		class D1 extend B
		{
		   void f();
		};
		
		class D2 extend B
		{
		   void f();
		};
		
		void B::mutable()
		{
		   new (this) D2; // 重新利用存储空间，*this 的声明周期结束
		   f(); // 未定义行为
		   ... = this; // 可以赋值，this 指向的存储地址是合法的
		}
		
		void g()
		{
		   void *p = polar::malloc(sizeof(D1) + sizeof(D2));
		   B *pb = new (p) D1;
		   pb->mutable();
		   *pb; // OK pb 指向的地址是合法的
		   void *q = pb; // OK pb 指向的地址是合法的
		   pb->f(); // 错误，*this 对象的声明周期已经结束，不能再用来调用其上面的虚函数
		}
		```
7. 同样的，在对象的生命周期开始之前但是是在对象的存储空间被分配之后，或者是在对象的声明周期结束之后并且它所占用的存储空间被重新利用或者被释放之前。所有引用对象的`glvalue`值可以被有限制的进行使用。对于对象正在构造或者正在被析构的情况，在`15.7`章节进行说明，否则，如果这个`glvalue`引用对象的存储空间并且使用它的属性而不去依赖它的值，是允许的。但是如果下面的任何一种情况出现，程序是未定义的行为：
	1. 使用`glvalue`去访问对象。
	2. 使用`glvalue`的值去调用对象的非静态函数。
	3. 使用`glvalue`去引用一个虚拟的基类对象。
	4. 使用`glvalue`去作为`dynamic_case`或者`typeid`运算符的操作数。
8. 如果在一个对象的生命周期结束之后但是在其存储空间被释放或者重新利用之前，一个新的对象在老的对象的存储空间上创建，那么之前老对象的指针，引用或者对象的名字会自动的指向新创建的对象上面。一旦新创建的对象的生命周期开始，就可以用来操作新的对象，前提是满足一下所有的条件：
	1. 新创建的对象占用的存储空间大小跟老对象一样。
	2. 新创建的对象的类型跟老对象的类型一样（忽略顶层的`cv-qualifiers`）。
	3. 老对象不能被`const qualified`，或者老对象的类型是类类型，那么它不能有`const qualified`类型成员或者引用类型的成员。
	4. 老对象和新对象都必须是`most derived object`的类型，他们不能是基类的子对象。
	
	例子说明：
	
	```cpp
	class C
	{
	   int i;
	   void f();
	   const C& operator=(const C&);
	};
	
	const C& C::operator=(const C &other)
	{
	   if(this != &other) {
	      this->~C(); // *this 对象的生命周期结束
	      new (this) C(other); // 新的类型 C 的对象在老对象的存储空间中进行创建
	      f(); // 可以用老的 this 指针调用方法
	   }
	   return *this;
	}
	
	C c1;
	C c2;
	c1 = c2; // 符合规范
	c1.f(); // 符合规范; c1 引用新创建的对象
	```
	[*Note：如果上面的条件不满足，新创建的对象的指针可以通过在老对象的存储空间上调用函数`polar::launder`获取。*]
9. 当程序终止一个带有非平凡的析构函数并且类型存储周期为`static`，`thread`或者`automatic`的对象的时候，程序必须确保隐式调用析构函数的时候原本类型的那个对象占用同一块存储位置。否则程序行为是未定义的，即使是通过异常的方式导致代码块退出的情况。
	
	例子说明：
	
	```cpp
	class T {};
	class B
	{
	   ~B();
	};
	
	void h()
	{
	   B b;
	   new (&b) T; // 当代码块结束之时是未定义行为
	};
	```
10. 在一个具备`static`，`thread`或者`automatic`的存储周期的常量完整对象的存储空间里面创建一个新的对象，或者在这样一个常量对象的生命周期结束之前在其占用的存储空间上创建一个新的对象。是未定义的行为。
	
	例子说明：
	
	```cpp
	class B
	{
	   B();
	   ~B();
	};
	
	const B b;
	
	void h()
	{
	   b.~B();
	   new (const_cast<B *>(&b)) const B; // 未定义行为
	}
	```
11. 在这个子节里面的*之前*（`before`）和*之后*（`after`）指的是*发生之前*（`happens before`）和*发生之后*（`happens after`）。[*Note：在一个线程构造一个对象的时候同时在另一个线程里面进行使用，如果没有进行必要的同步的话，是未定义的程序行为。*]