# 程序与连接

1. 一个成员由一个或者多个转换单元连接在一起组成，转换单元是由下面的声明单元组成：
	<pre>
	translation-unit:
		declaration-seq<sub>opt</sub>
	</pre>
2. 当一个名字可能指示同一个对象，引用，函数，类型，模板或者命名空间或者一个从其他命名空间通过声明引入的值的名字的的时候被称作名字可连接性：
	1. 当一个名字具有外部连接性（`external linkage`）的时候，它指示的程序实体可以在其他转换单元的作用域中进行引用或者同一个转换单元的其他作用域进行引用。
	2. 当一个名字具有内部连接性（`internal linkage`）的时候，它指示的程序实体可以在同一个转换单元的不同作用域里面进行引用。
	3. 当一个名字没有连接性的时候（`no linkage`），它指示的程序实体不能在其他作用域进行引用。
3. 一个命名空间里面的名字满足下面的条件时，它具备内部链接性：
	1. 一个变量，函数或者函数模板被显式定义成`static`
	2. 一个`non-volatile`和`const-qualified`类型的非`inline`变量既没有显示的声明成`extern`也没有在前面被声明成具备外部连接性。
4. 一个匿名的命名空间或者一个直接或者间接定义在匿名命名空间里面的命名空间具有内部链接性。除此之外的命名空间具备外部连接性。一个具有命名空间作用域的名字，如果没有指定为内部连接性的话，如果它是下面的其中的一种的话，具备跟它闭包命名空间一样的连接性：
	1. 一个变量。
	2. 一个函数。
	3. 一个具有名字的类类型或者一个出现在`typedef declaration`里面的为了指定可连接性而具备一个`typedef`名字的未命名类类型。
	4. 一个具有名字的枚举类型或者一个出现在`typedef declaration`里面的为了指定可连接性而具备一个`typedef`名字的未命名枚举类型。
	5. 一个模板。
5. 更进一步，一个成员函数，一个静态数据成员，一个具备名字的类类型，或者一个类作用域下面的枚举类型或者一个未命名的类类型，或者一个定义在一个为了连接性而指定`typedef`名字的未命名类类型中的枚举类型，具备相同的连接性，如果有的话，他们都跟他们所在类类型的名字的连接性一样。
6. 一个声明在代码块中的函数或者在一个代码块通过代码块`extern`声明的一个变量也同样具备连接性。如果在当前的作用域中具备一个相同名字和类型的实体的带连接性的可见的声明，这个时候会忽略最里层的闭包作用域里面的声明，在当前作用域的声明同样的实体将获得跟前面声明一样的连接性。如果这样的具备连接性的声明有两个匹配结果的时候，程序是不符合规范的。否则，没有找到匹配的声明的时候，代码块作用域里面的实体具有外部连接性。在一个转换单元中同样的实体既声明有外部连接性又有内部连接性的时候，程序是不符合规范的。
	
	例子说明：
	```cpp
	static void f();
	static int i = 0; // #1
	void g()
	{
	   extern void f(); // 内部块作用域，往前看，具备内部连接性
	   int i; // #2 i 没有连接性
	   {
	      extern void f(); // 内部块作用域，往前看，具备内部连接性
	      extern int i; // #3 外部连接性，编译错误 
	   }
	}
	```
	如果没有 #2 的定义，#3 将具备 #1 的内部连接性，但是 #2 把 #1 的声明隐藏了，导致 #3 具备外部连接性，违反了在一个转换单元中只有一种连接性的规则，所以程序是不符合规范的。
7. 在一个代码块作用域中的一个带有连接性的实体声明没有找到一个可以进行引用的声明的时候，这个实体声明成为代码块所在的最里层的闭包命名空间的成员，然而，这个声明没有在它的命名空间作用域中引入新的成员函数。
	
	例子说明：
	
	```cpp
	namespace X
	{
	   void p()
	   {
	      q(); // 编译错误，q 还没有声明
	      extern void q(); // q 是命名空间 X 的成员
	   }
	   
	   void middle()
	   {
	      q(); // q 还没有声明
	   }
	   
	   void q() {} // 定义 X::q
	}
	void q() {} // 其他不一样的 实体 q
	```
8. 不符合以上规则的名字都不具有连接性。此外，除了特殊说明，在块作用域中声明的名字没有连接性。
9. 一个类型具有连接性当且仅当具备下面的条件：
	1. 它是一个被命名的类类型或者枚举类型（或者具备为了连接性指定的`typedef`类型的名字的类类型或者枚举）同时类型的名字具备连接性。
	2. 一个具备连接性的类的嵌套未命名类类型或者枚举类型。
	3. 一个类模板的特殊化。
	4. 一个基础数据类型（fundamental type）。
	5. 一个除了类类型和枚举类型的复合数据类型，由那些具备连接性的类型复合而来。
	6. 具有连接性类型的`cv-qualified`版本。
10. 一个没有连接性的类型不能用在一个具备外部连接性的变量或者函数声明中，除非下面的两种情况：
	1. 这个实体具备 `C` 语言连接性
	2. 这个实体没有`odr-used`或者在定义在了同一个转换单元中。
	[*Note: 换句话说，一个没有连接性的类型中包含了一个类类型或者枚举类型，那么不能在当前转换单元之外对这个实体进行声明。一个具备外部性的实体使用这样的类型进行声明将不能对应程序范围里其他任何转换单元里面的实体，如果这样的实体被`odr-used`，那么必须在其所在的转换单元中进行定义。一个具有连接性的类类型可能包含一些成员，这些成员所对应的类型没有连接性，并且在判断一个类型是否具有连接性的时候，`typedef` 名字将被忽略掉。*]
	
	例子说明：
	
	```cpp
	template <typename T>
	class B
	{
	   void g(T) {}
	   void h(T);
	   friend void i(B, T) {}
	};
	
	void f()
	{
	   class A { int x; }; // 不具备连接性
	   A a = { 1 }; 
	   B<A> ba; // 声明了 B<A>::g(A) 和 B<A>::h(A)
	   ba.g(a); // OK
	   ba.h(a); // 错误， B<A>::h(A) 没有在转换单元里面定义
	   i(ba, a); // Ok
	}
	```
11. 两个名字相同并且定义在两个不一样的命名空间应该指定同一个变量，函数，类型，模板或者命名空间，如果满足以下所有条件：
	1. 两个名字都具有外部连接性或者两个名字都具有内部链接性同时定义在同一个转换单元里面。
	2. 两个名字都引用相同命名空间的成员或者同一个类类型中不通过继承得到的成员。
	3. 两个名字都指定函数时候，函数的`parameter-type-lists`要一致。
	4. 两个名字都指定函数模板的时候，原型必须一样。
12. 在进行针对类型的调整之后（比如将`typedef`名字替换成原来的类型名），指向一个指定的变量或者函数的所有类型声明要一致。除了数组类型声明的时候，可以指定不一样的数组长度而造成的类型不一致的情况。违反这条规则的时候，不要求输出诊断信息。
13. [*Note：连接到非极语言的声明的时候请参见`linkage-specification`。*]