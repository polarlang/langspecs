# 内存和对象
## 内存模型
1. 在极语言的内存模型中最基础的存储单元是字节`byte`。一个`byte`的大小至少要能容纳任何在执行字符集里面的字符成员和UTF8编码规范的八比特的编码单元并且由连续的比特序列组成，比特序列的长度由极语言编译器决定。最不重要的比特（`least significant bit`）叫做`low-order bit`；最重要的比特叫做`high-order bit`，系统提供给极语言的内存是由一个或者多个字节序列组成的。没有个字节都有一个唯一的地址。
2. 一个内存位置是一个标量类型的对象或者由相邻的长度不为零的比特位域的最长序列。[*Note: 语言的各种特性，比如引用或者虚函数，可能使用一些程序员不可见但是由编译器进行管理的内存位置。*]两个或者多个运行的线程同时访问不同的内存位置不会相互干扰。
3. [*Note: 一个位域和其相邻的非位域字段是在不同的内存位置，因此可以被两个或者多个线程同时访问而不会相互干扰。这个规则对两个位域其中一个定义在嵌套的结构体而另一个不是的情况或者两个位域之间被长度为零的位域隔开，或者被不是位域的字段隔开。同时更新结构体中两个中间都是长度不为零的位域是不安全的。*]
	
	例子说明
	
	```cpp
	struct 
	{
	  char a;
	  int b: 5,
	  c: 11,
	  :0,
	  d: 8,
	  strcut { int ee: 8} e;
	}
	```
	以上代码含有四个内存位置成员a，位域d，位域e.ee是不同的内存位置，可以同时进行修改而不会相互影响。位域b和位域c是第四个内存位置，它两不能同时进行修改，但是成员a和位域b可以同时进行修改。

## 对象模型

1. 在极语言中对对象有创建，销毁，引用，访问和操作等活动。对象的创建按照定义，通过`new-expression`创建，当隐式的改变联合体当前活动成员的时候或者当一个临时对象被创建。在对象被创建到其整个生命周期，直到最后被销毁，占用一段区域的存储空间。[*Note: 函数不是对象，尽管可能函数也会像对象那样占用一定的存储空间。*][*todo: 函数不是`first class`类型？*]对象的属性在对象创建之后进行检查。一个对象可以有名字。一个对象可以有存储周期，并会影响对象的生命周期。一个对象具有类型。一些对象是多态的，由编译器负责生成一些跟这些多态类相关的信息，在运行时能够判断对象的类型。对于其他类型的对象的值，通过访问它的`expressions`的类型来决定。
2. 对象可以包含其他的对象，叫做子对象`subobjects`。一个子对象可以是成员子对象（`member subobject`），也可以是基类子对象（`base class subobject`）或者一个数组的元素子对象。一个不是其他任何对象的子对象的对象称作一个完整的对象（`complete object`）。一个对象在成员对象或者数组元素`e`所在的存储区域创建的时候，新创建的对象是`e`的所属对象的子对象的话，需要同属满足下面的条件：
	1. `e`的宿主对象的作用域已经开始，但是还没有结束。
	2. 新创建的对象的存储空间正好覆盖了`e`所关联的存储空间。
	3. 新创建的对象的类型跟`e`的类型一样。(忽略cv-qualification）
	
	[*Note: 如果新的子对象中包含有引用成员或者常量子对象成员，原来对象的名字不能用来访问新创建的对象。*]
	
	例子说明：
	
	```cpp
	class X
	{
	   const int n;
	};
	
	union U
	{
	   X x;
	   float f;
	};
	
	void tong()
	{
	   U u = {{ 1 }};
	   u.f = 5.0f; // OK 创建一个 u 的子对象
	   X *p = new (&u.x) X {2}; // OK 创建一个 u 的子对象
	   assert(p->n == 2); // OK
	   assert(*polar::lanuder(&u.x.n) == 2); // OK
	   assert(u.x.n == 2); // 为定义行为，不能通过 u.x 对创建的新对象进行访问
	}
	```
3. 如果一个完整的对象在一个类型`e`为`array of N unsigned char`的对象或者为`array of N polar::byte`的对象所关联的对象上创建，当同时满足下面的条件时数组将为新创建的对象提供存储空间：
	1. `e`的生命周期已经开始并且还没有结束。
	2. 新创建的对象的存储空间符合`e`所关联的存储空间的大小。
	3. 没有更小的数组对象满足这些限制。
	[*Note: 如果数组的存储空间被一个对象占用，那么那个对象的生命周期结束，因为它的存储空间被重新使用了。*]
	
	例子说明：
	
	```cpp
	template<typename ...T>
	struct AlignedUnion
	{
	   alignas(T...) unsigned char data[max(sizeof(T)...)];
	};
	
	int f()
	{
	   AlignedUnion<int, char> au;
	   int *p = new (au.data) int; // OK, au.data provides storage
	   char *c = new (au.data) char(); // OK, ends lifetime of *p
	   char *d = new (au.data + 1) char();
	   return *c + *d; // OK
	}
	
	struct A { unsigned char a[32]; };
	struct B { unsigned char b[16]; };
	A a;
	B *b = new (a.a + 8) B; // a.a 提供存储空间给 *b
	int *p = new (b->b + 4) int; // b->b 提供存储空间给 *p
	                             // a.a 没有直接提供存储空间给 *p
	                             // 但是 *p 嵌套在 a 中
	```
4. 当满足下面任何一条时候，我们就说对象`a`嵌套在（`nested within`）对象`b`中：
	1. 对象`a`是对象`b`的子对象。
	2. 对象`b`给对象`a`提供存储空间。
	3. 存在一个对象`c`，对象`a`嵌套在对象`c`里面，对象`c`嵌套在对象`a`里面。
5. 对于任何对象`x`，都存在某个对象叫做对象`x`的完整对象。判断条件如下：
	1. 如果`x`是完整对象，那么`x`的完整对象是它自己。
	2. 否则，`x`的完整对象是唯一包含对象`x`的完整对象。
6. 如果一个完整对象，一个数据成员或者一个数组元素是一个类类型，他们的类型被称作`most derived class`，用来这个类类型与其基类的子对象。一个`most derived class`或者非类类型的对象叫做`most derived object`。
7. 除非是位域，一个`most derived object`应该占用一个或者多个字节的存储空间。基类子对象可能不占用存储空间。一个含有平凡复制能力（`trivially copyable`）或者标准内存布局（`standard-layout`）类型的对象应该占用连续的字节序列的存储空间。
8. 除非是位域或者是大小为零的基类子对象，对象的地址是其占用的存储空间的首字节的地址。一个生命周期相互覆盖的两个非位域的两个对象，如果一个嵌套在另一个里面或者至少一个是大小为零的基类子对象并且两个对象的类型不一样，这两个对象的地址可能一样，否则他们具有不同的地址。
	
	例子说明：
	
	```cpp
	static const char test1 = ’x’;
	static const char test2 = ’x’;
	const bool b = &test1 != &test2; // 永远为 true
	```
9. [*Note: 极语言提供一些最基本的类型定义和几种从现有基础类型合成新类型的机制。*]

## 对象生命周期

1. 对象或者引用的生命周期是对象或者引用的运行时属性。一个对象如果是一个类类型或者聚合类型并且它自己或者它的一个子对象被一个非平凡的构造函数初始化，那么我们说这个对象具备有意义的初始化（`non-vacuous initialization`）[*Note: 被平凡的复制或者移动构造函数初始化也是一个具备意义的初始化。*]，当下面的条件全部满足的时候，类型`T`的对象的生命周期开始：
	1. `T`的存储空间被合理的进行了对齐并且类型`T`的大小已经被获取。
	2. 如果`T`的对象具有有意义的初始化，它的初始化已经完成。
	除了下面这种情况，如果对象是一个联合体的成员或者子对象，它的生命周期只有当前在联合体中已经初始化完成之后才开始。
2. 当下面的情况中一种发生时，对象的作用域结束：
	1. 如果类型`T`是一个具有非平凡的析构函数的类类型，它的析构函数开始调用。
	2. 对象占用的存储空间被释放或者被一个不是对象`o`的嵌套对象所占用。
3. 一个引用的生命周期开始于他被初始化，然后跟标量数据类型的对象一样的方式结束。
4. 在本文档中归于对象或者引用的属性只在其声明周期里面进行应用。[*Note: 在一个对象的声明周期开始之前或者结束之后去使用一个对象的时候需要特别注意，同样的一个正在构造中的对象和一个正在被析构的对象的使用也跟正在生命周期已经开始且没有结束中的对象有很大的区别。*]
5. 一个程序可能通过重新利用一个对象的存储空间的方式来终止任何一个对象的生命周期或者通过调用一个类类型的非平凡的析构函数来终止。对应一个具有非平凡的构造函数的类类型，当它所占用的存储空间被重新利用或者被释放，不要求程序显式的对其析构函数进行调用。然后如果一个程序没有显示的调用析构函数或者没有用`delete-expression`去释放占用的空间，析构函数不能隐式的被调用并且任何依赖析构函数副作用的行为都是未定义的。
6. 在对象的生命周期开始之前但是在对象的存储空间已经被分配之后，或者在对象的生命周期结束之后但是在对象占用的存储空间被回收或者重新利用之前，这个时候指向对象所占用的存储空间的指针只能以受限的方式进行使用。当对象正在构造或者析构的时候，指向对象分配的存储区域的指针的类型是`void *`，是被很好的定义了。通过这样的指针间接访问存储区域是可以的，但是如果形成一个左值的话，只能按照受限的方式进行使用。如果下面任何一条满足，程序都是未定义的：
	1. 对象有一个非平凡的析构函数，这个指针被用在了`delete-expression`表达式中。
	2. 指针用来访问非静态数据成员或者非静态函数成员。
	3. 指针隐式的转换成指向虚拟基类的指针类型。
	4. 除了后面的转换类型，转换成`cv void`类型或者指向`cv void`类型的指针并且随后变成指向`cv char`或者`cv unsigned char`或者`cv polar::byte`类型的指针。
	5. 指针被用在了转换操作符`dynamic_cast`的操作数：
		
		例子说明：
		
		```cpp
		import cpolarlib;
		
		class B
		{
		   virtual void f();
		   void mutable();
		   virtual ~B();
		};
		
		class D1 extend B
		{
		   void f();
		};
		
		class D2 extend B
		{
		   void f();
		};
		
		void B::mutable()
		{
		   new (this) D2; // 重新利用存储空间，*this 的声明周期结束
		   f(); // 未定义行为
		   ... = this; // 可以赋值，this 指向的存储地址是合法的
		}
		
		void g()
		{
		   void *p = polar::malloc(sizeof(D1) + sizeof(D2));
		   B *pb = new (p) D1;
		   pb->mutable();
		   *pb; // OK pb 指向的地址是合法的
		   void *q = pb; // OK pb 指向的地址是合法的
		   pb->f(); // 错误，*this 对象的声明周期已经结束，不能再用来调用其上面的虚函数
		}
		```
7. 同样的，在对象的生命周期开始之前但是是在对象的存储空间被分配之后，或者是在对象的声明周期结束之后并且它所占用的存储空间被重新利用或者被释放之前。所有引用对象的`glvalue`值可以被有限制的进行使用。对于对象正在构造或者正在被析构的情况，在`15.7`章节进行说明，否则，如果这个`glvalue`引用对象的存储空间并且使用它的属性而不去依赖它的值，是允许的。但是如果下面的任何一种情况出现，程序是未定义的行为：
	1. 使用`glvalue`去访问对象。
	2. 使用`glvalue`的值去调用对象的非静态函数。
	3. 使用`glvalue`去引用一个虚拟的基类对象。
	4. 使用`glvalue`去作为`dynamic_case`或者`typeid`运算符的操作数。
8. 如果在一个对象的生命周期结束之后但是在其存储空间被释放或者重新利用之前，一个新的对象在老的对象的存储空间上创建，那么之前老对象的指针，引用或者对象的名字会自动的指向新创建的对象上面。一旦新创建的对象的生命周期开始，就可以用来操作新的对象，前提是满足一下所有的条件：
	1. 新创建的对象占用的存储空间大小跟老对象一样。
	2. 新创建的对象的类型跟老对象的类型一样（忽略顶层的`cv-qualifiers`）。
	3. 老对象不能被`const qualified`，或者老对象的类型是类类型，那么它不能有`const qualified`类型成员或者引用类型的成员。
	4. 老对象和新对象都必须是`most derived object`的类型，他们不能是基类的子对象。
	
	例子说明：
	
	```cpp
	class C
	{
	   int i;
	   void f();
	   const C& operator=(const C&);
	};
	
	const C& C::operator=(const C &other)
	{
	   if(this != &other) {
	      this->~C(); // *this 对象的生命周期结束
	      new (this) C(other); // 新的类型 C 的对象在老对象的存储空间中进行创建
	      f(); // 可以用老的 this 指针调用方法
	   }
	   return *this;
	}
	
	C c1;
	C c2;
	c1 = c2; // 符合规范
	c1.f(); // 符合规范; c1 引用新创建的对象
	```
	[*Note：如果上面的条件不满足，新创建的对象的指针可以通过在老对象的存储空间上调用函数`polar::launder`获取。*]
9. 当程序终止一个带有非平凡的析构函数并且类型存储周期为`static`，`thread`或者`automatic`的对象的时候，程序必须确保隐式调用析构函数的时候原本类型的那个对象占用同一块存储位置。否则程序行为是未定义的，即使是通过异常的方式导致代码块退出的情况。
	
	例子说明：
	
	```cpp
	class T {};
	class B
	{
	   ~B();
	};
	
	void h()
	{
	   B b;
	   new (&b) T; // 当代码块结束之时是未定义行为
	};
	```
10. 在一个具备`static`，`thread`或者`automatic`的存储周期的常量完整对象的存储空间里面创建一个新的对象，或者在这样一个常量对象的生命周期结束之前在其占用的存储空间上创建一个新的对象。是未定义的行为。
	
	例子说明：
	
	```cpp
	class B
	{
	   B();
	   ~B();
	};
	
	const B b;
	
	void h()
	{
	   b.~B();
	   new (const_cast<B *>(&b)) const B; // 未定义行为
	}
	```
11. 在这个子节里面的*之前*（`before`）和*之后*（`after`）指的是*发生之前*（`happens before`）和*发生之后*（`happens after`）。[*Note：在一个线程构造一个对象的时候同时在另一个线程里面进行使用，如果没有进行必要的同步的话，是未定义的程序行为。*]

## 存储周期

1. 存储周期是包含对象的存储来确定自己最小可能生命周期的一个属性。存储周期通过对象的构造来确定并且是下面中的一种：
	1. 静态存储周期
	2. 线程存储周期
	3. 自动存储周期
	4. 动态存储周期
2. 具备静态，线程和自动存储周期通过声明或者隐式的通过编译器创建获取，具备动态存储周期的对象是通过`new-expression`创建得到的。
3. 存储周期的类型同样适用于引用类型。
4. 在存储空间的生命周期结束后，所有指向存储空间的指针的值都是非法的值，不能再进行使用。间接的获取指针的值并且把指针的值传递给资源释放函数是未定义的程序行为，对于不合法的存储空间的指针的其他用法之后产生的结果由编译器进行制定。

### 静态存储周期

1. 所有没有动态存储周期，没有线程存储周期或者不是局部的变量都具有静态存储周期。这些变量实体的存储周期一直持续到程序结束。
2. 如果一个具备静态存储周期的变量具有一个初始化器或者一个具有额外作用的析构器，那么即使这些过程看着没有用，编译器也不能省略。除非变量是一个类类型的对象或者它的复制移动可以按照`15.8`中描述的方式进行消除。
3. 在局部代码块中通过`static`修饰的变量也具备静态存储周期。
4. 如果以类的数据成员被`static`修饰那么这个数据成员具备静态存储周期。

### 线程存储周期

1. 所有通过`thread_local`关键字声明的变量都具备线程存储周期的属性。这些实体的存储周期应该持续到创建它的线程结束。每个线程都有一个不一样的对象或者对象的引用。并且在当前的线程中通过声明的名字进行实体的引用。
2. 一个具有线程存储周期的变量，应该在它第一个`odr-use`之前进行初始化，如果一个这样的变量被构建，那么在线程退出的时候应该被销毁。

### 自动存储周期

1. 在块作用域中的一个变量如果没有声明成静态存储周期，线程存储周期或者`extern`，那么这个变量具有自动存储周期属性。
2. [*Note：我们在`9.7`章节介绍自动存储周期变量的初始化和销毁。*]
3. 如果一个具有自动存储周期的变量具有一个初始化器或者带有一个额外左右的析构器，那么编译器不能块结束之前销毁他或者消除这个变量，及时它看起来没有任何作用，除非他是一个类类型的对象或者复制移动可以按照`15.8`章节进行。

### 动态存储周期

1. 对象可以在动态的在程序运行时通过`new-expressions`表达式进行创建和通过`delete-expressions`进行销毁。极语言编译器应该提供创建动态存储周期的全局操作运算符函数 `operator new`，`operator new[]`或者销毁动态存储周期的全局操作符函数`operator delete`和`operator delete[]`。
2. 标准库提供默认的全局资源分配和销毁的函数定义。一些全局的存储分配和释放函数是可以进行替换的，为这些可以替换的函数，极语言必须提供只多一个定义。下面的这些全局的存储空间分配和销毁函数隐式的在所有的转换单元里面的全局作用域中进行了声明。
	
	声明代码：
	
	```cpp
	[[nodiscard]] void* operator new(polar::size_t);
	[[nodiscard]] void* operator new(polar::size_t, polar::align_val_t);
	
	void operator delete(void*) noexcept;
	void operator delete(void*, polar::size_t) noexcept;
	void operator delete(void*, polar::align_val_t) noexcept;
	void operator delete(void*, polar::size_t, polar::align_val_t) noexcept;
	
   [[nodiscard]] void* operator new[](polar::size_t);   [[nodiscard]] void* operator new[](polar::size_t, polar::align_val_t);
   
   void operator delete[](void*) noexcept;
   void operator delete[](void*, polar::size_t) noexcept;
   void operator delete[](void*, polar::align_val_t) noexcept;
   void operator delete[](void*, polar::size_t, polar::align_val_t) noexcept;
	```
	隐式声明只包含函数`operator new`，`operator new[]`，`operator delete`和`operator delete[]`。[*Note: 隐式声明没有引入名字`polar`，`polar::size_t`，`polar::align_val_t`和任何在标准库中用来声明这些名字所用的名字。所以所有使用`new-expression`，`delete-expression`和所有引用这些函数的调用时候引入 `new module` 是符合规范的。然而使用`polar`或者`polar::size_t`或者`polar::align_val_t`是不符合规范的，除非引用相关的模块。*] 资源分配或者资源释放函数也可以被任何类进行声明和定义。
3. 极语言中的所有的存储资源的分配和释放的函数语义，包含标准库提供的默认版本，都必须符合下面两节中定义的语义规范。

#### 存储空间分配函数

1. 一个存储空间分配函数要么是一个类的成员函数要么是全局函数。如果存储空间分配函数如果在一个非全局命名空间或者在全局命名空间中被声明成静态函数，那么程序是不符合规范的。返回值应该为`void *`类型。函数的第一个参数类型应该为`polar::size_t`并且不能有默认值，第一个参数应该被解释成请求分配的存储空间的所需字节数，存储空间分配函数可以为模板函数。如果是模板函数的话，返回值和第一个参数的要求跟非模板函数保持一致。函数模板存储空间分配函数应该有两个或者多个参数。
2. 存储空间分配函数尝试分配请求数量的存储空间。如果分配成功，将返回一个大小至少是请求大小字节数且连续的存储空间的首字节的地址。对于通过资源分配函数分配的存储空间的内容没有任何要求。对两次连续调用空间分配函数得到的两个空间存储存储空间的顺序，连续性，存储空间的初始值没有做任何规定。返回的地址必须进行合适的对齐，这个地址要能转换成任何合适的完整对象的类型并且可以用来访问分配的存储空间里面的对象和数组。（直到存储空间被显式的调用存储空间释放函数而进行释放）即使请求分配的资源大小为零，分配请求也可能失败。如果存储空间请求分配成功，返回的地址`p0`应该跟上一次分配成功返回的地址`p1`不一样，除非`p1`后来被传递给了`operator delete`进行了资源释放。`p0`代表一块与存储空间调用者所有可访问的存储空间都不相交的一块存储空间。间接访问一个请求分配大小为零返回的地址，程序的行为是未定义的。
3. 一个分配函数分配资源出错，系统应该调用当前安装的`new-handler`，如果有的话。[*Note: 程序提供的存储空间分配函数可以通过`polar::get_new_handler`获取系统当前安装的`new-handler`函数的地址。*]一个存储分配函数如果指定了`non-throwing exception specification`，那么当分配失败的时候，应该返回一个空指针。任何其他的存储空间分配函数失败时候应该抛出一个跟`polar::bad_alloc`相容的异常类型。
4. 一个全局的资源分配函数只能通过`new expression`调用或者使用函数的调用语法进行调用或者间接的在极语言标准库的一些函数中进行调用。[*Note: 全局存储空间分配函数不为具有静态存储周期的对象或者具有线程存储周期的对象或者引用或者`polar::type_info`类型的对象或者异常对象分配存储空间。*]

#### 存储空间释放函数

1. 存储空间释放函数应该是一个类的成员函数或者一个全局函数。如果一个存储空间释放函数在一个全局命名空间之外的命名空间中进行声明，或者声明在全局命名空间但是被声明成`static`，程序是不符合规范的。
2. 存储空间释放函数的返回值应该是`void`类型，第一个参数的类型为`void *`类型。一个存储资源释放函数可能有多个参数。一个通常的存储空间释放函数有如下的特点：
	1. 只有一个参数。
	2. 有两个参数，第二个参数的类型是`polar::align_val_t`或者`polar::size_t`。
	3. 三个参数，第二个参数的类型是`polar::size_t`并且第三个参数的类型是`polar::align_val_t`。
	存储空间释放函数可以是函数模板的一个实例，第一个参数类型和返回值的类型必须是非模板参数，并且跟非函数模板的参数和返回值类型一样。[*Note: 这条规则指的是函数的返回值类型是`void`和第一个参数的类型是`void *`。*]存储空间分配函数模板有两个或者两个以上的参数。一个函数的模板的实例永远不是一个普通的存储空间释放函数，尽管函数的原型一样。
3. 一个储存空间释放函数如果以抛出异常而终止，程序行为是未定义的。传递给存储空间释放函数的第一个参数可以是一个空指针，这个时候如果存储空间释放函数如果是由标准库提供的默认存储空间释放函数，这个调用没有效果。
4. 传递给标准库默认的存储空间释放函数的第一个参数是一个非空的指针，那么函数应该对指针所引用的存储空间进行释放，这个存储空间的存储周期结束。

#### 安全导向指针（Safely-derived pointers）

1. 满足下面的任何条件的指针叫做可追踪的指针对象（`traceable pointer object`）：
	1. 一个对象指针类型的对象。
	2. 一个数值类型的大小至少跟`polar::intptr_t`类型一样大。
	3. 窄字符类型数组（`narrow character type`）的大小和对齐跟这些类型对应指针对象类型想匹配（todo: 这里不是很明确）
2. 一个指针叫做一个指向动态存储周期的对象的安全导向的指针，必须满足下面的条件：
	1. 指针的值是调用标准库中的运算符函数`::operator new(polar::size_t)`或者`::operator new(polar::size_t, polar::align_val_t)`获取的。
	2. 间接的通过安全导向的指针的值获取的一个左值的指针，对其解引用得到一个对象或者子对象，然后对其取址得到的结果。
	3. 对安全导向指针进行四则运算得到的结果指针。
	4. 对安全导向指针进行符合规范的指针类型转换得到的指针。
	5. 对安全导向指针进行`reinterpret_cast`得到的指针。
	6. 对安全导向指针的整数表示进行`reinterpret_cast`得到的指针。
	7. 一个从可追踪指针对象得到的对象，在对象复制的时候，源对象具有一个安全导向指针的值。
3. 安全导向指针的整数表示是一个大小至少跟`polar::intptr_t`一样大的整数类型并且满足下面其中一个条件：
	1. 对安全导向指针的值进行`reinterpret_cast`得到的值。
	2. 对安全导向指针的整数表示的值进行一个合法的转换得到的值。
	3. 一个从可追踪对象复制得到的对象，在复制的时候源对象有包含一个安全导向指针的整数表示。
	4. 对安全导向指针的整数表示进行加或者位运算得到的结果，如果对这个结果进行`reinterpret_cast<void*>`得到的结果应该跟直接在安全导向指针应用`reinterpret_cast<void*>`的结果保持一致。
4. 极语言编译器可能有弱安全性指针类型（`relaxed pointer safety`），这种指针的值的有效性不依赖安全导向性指针的值。极语言编译也可能实现强安全性指针类型，这种指针引用的动态存储空间地址不是一个安全导向指针的值，那么它的指针的值是无效的，除非被引用的完整对象在前面已经被声明可达。[*Note: 使用一个无效的指针的程序行为是未定义的，包括把其传递给存储空间释放函数。及时当不安全的指针的值跟安全导向指针的值一样，程序行为也是未定义的。*]，一个安全导向的指针使用弱安全指针还是强安全指针类型由编译器自己决定。

### 子对象的存储周期

1. 类的子对象的存储周期或者引用成员的存储周期跟所在的类的存储周期保持一致。

## 对齐

1. 对象类型是有地址对齐要求（`alignment requirements`）的，也就对象类型存储空间存放的地址跟对象类型的大小有关系。对齐`alignment`是指连续两个特定类型的对象的存储空间间隔的字节数。对象类型会给该类型的所有对象增加一个对齐要求。严格的对齐可以通过对齐指示符获取（`alignment specifier`）。
2. 基础对齐是一个在所有向下文环境下都能进行对齐的一个最大对齐值，这个值等于`alignof(polar::max_align_t)`，一个对象的对齐值在其作为完整对象或者子对象的时候，可能不一样。
	
	例子说明：
	```cpp
	class B
	{
	   long double d;
	};
	
	class D extend B
	{
	   char c;
	};
	```
	当类型`D`的对象是一个完整对象，它有一个类型`B`的对象，所以类型`D`的对象也得为`long double`进行合理的对齐。当类型`D`的对象作为其他对象的子对象的出现时的时候，它的子对象可能有不一样的对齐要求。`alignof`可以影响完整对象类型的对齐要求。
3. 一个扩展的对齐要求是对齐值大于`alignof(polar::max_align_t)`的对齐。由编译器觉得是否在所有的上下文中支持或者在特定的上下文中支持这种对齐方式。一个具有扩展对齐要求的对象类型叫做过度对齐类型（`over-aligned type`）。[*Note: 过度对齐类型中包含一个应用扩展对齐的类类型成员。可能通过一个非静态的数据成员。*]。一个新的扩展对齐是对齐值大于`__POLAR_DEFAULT_NEW_ALIGNMENT__`的对齐。
4. 对齐值的类型使用`polar::size_t`进行表示。合法的对齐中只包好在基础类型上应用`alignof`得到的值加上一些由编译器的指定的值，可能为空。所有的对齐值都必须是无符号的2的幂。
5. 对齐的顺序是`weaker`到`stronger`或者`stricter`对齐。等级高的对齐要求具有更大的对齐值。一个对象满足`stronger`的对齐要求就一定满足所有的`weaker`对齐要求。
6. 一个完整对象的对齐值可以通过`alignof`表达式获取。更近一步，窄字符类型拥有最弱的对齐要求。[*Note: 这样窄字符类型可以用作类型对象对齐区域的数据类型。*]
7. 对齐值的比较是有意义的并且提供以下的明显的结果：
	1. 两个对齐值的整数表示相等那么对齐值相等。
	2. 两个对齐值的整数表示不相等那么对齐值不相等。
	3. 一个类型的严格对齐值大于其他类型的对齐值。
8. [*Note: 运行时的指针对齐函数可以用来获取一个缓冲区的对齐指针的对齐值；标准库中的对齐存储对象模板可以用来获取对齐的存储空间。*]
9. 当在一个不支持扩展对齐的上下文中请求扩展对齐，程序是不符合规范的。