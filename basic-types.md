# 数据类型

1. [在本节中，我们在忽略类型的具体表示的情况下给类型添加要求。极语言中有两种类型，基本类型和符合类型，类型是用来描述对象，引用或者函数。]
2. 对于任何一个非基类的可平凡复制的对象类型`T`，不管当前的对象里是否存有类型`T`合法的数据，组成类型`T`的对象的底层字节数据可以复制到`char`，`unsigned char`或者`polar::byte`类型的数组中。如果再把数组中的值复制会原来的对象存储空间里后，原来的对象的值不变。

	例子说明：
	```cpp
	constexpr const polar::size_t N = sizeof(T);
	char buf[N];
	T obj; // 对象 obj 初始化原始值
	polar::memcpy(buf, &obj, N); // 将对象中的数据复制到数组中,在这两次复制中，原来的对象的值可能会被改变
	polar::memcpy(&obj, buf, N); // 所有对象的标量成员都具有原来的值
	```
3. 对于任何可平凡复制的类型`T`，两个类型`T`的指针指向不同的两个对象`obj1`和`obj2`，这两个对象都不是基类类型。如果把对象`obj1`的底层字节复制到对象`obj2`的存储空间中，那么`obj1`和`obj2`具有同样的值。
	
	例子说明：
	
	```cpp
	T *t1p;
	T *t2p;
	polar::memcpy(t1p, t2p, sizeof(T));// t1p 指针引用的对象的值跟 t2p 指针引用的值一样
	```
4. 类型`T`的对象表示`object representation`是组成类型`T`的对象的`N`个`unsigned char`对象的组成的序列，`N`的大小是`sizeof(T)`。一个对象的值表示（`value representation`）是表示类型`T`的对象值的位序列。在对象表示中那些不表示值的位叫做填充位序列。在可平凡复制的对象中，对象的值表示是那些决定对象值的位序列的集合，是一个由编译器定义的离散元素的值集合。
5. 一个被声明了但是没有被定义的类类型，一个在特定上下文中的枚举类型，一个没指定长度的数组或者不完整元素类型叫做不完整定义的对象类型（`incompletely-defined object type`），不完整的对象类型和`cv void`统称不完成类型（`incomplete types`）。一个对象不能定义为不完整类型。
6. 一个类类型（比如类`X`）可能在转换单元的某个点是不完整类型，在后面的某个点又变成完整类型。在两个点类`X`具有相同的类型。当声明一个数组的时候，数组的元素的类型可以是不完整的类类型，这样的数组叫做不完整的数组。如果在转换单元后面某个点，数组元素类型变成完全类型，在这两个点上，两个数组的类型是一样的。一个数组可以不定义长度，那么它在转换单元中的某点是不完整的，但是在后面的某点可能是完整的。在这两个点数组的类型是不一样的。（一个是未知长度的数组，另一个是长度为`N`的数组）指向数组的指针是不知道数组的长度的。或者一个未知长度`typedef`名字的声明，是不能变完整的。

	例子说明：
	```cpp
	class X; // X 是不完整类型
	extern X *xp; // 是一个指向不完整类型的指针
	extern int arr[]; // 数组类型 arr 是不完整的类型
	typedef int UNKA[]; // UNKA 数组是不完整类型
	UNKA *arrp; // arrp 是指向不完整类型的指针
	UNKA **arrpp;
	
	void foo()
	{
	   xp++; // 编译错误，X 是不完整类型
	   arrp++; // 编译错误
	   arrpp++; // OK UNKA* 的大小是知道的
	}
	
	class X { int i; }; // X 到这里是完整的值
	int arr[10]; // 数组 arr 现在是完整的类型
	
	X x;
	void bar()
	{
	   xp = &x; // OK xp 是 X 类型的指针
	   arrp = &arr; // 编译错误，类型不一致
	   xp++; // OK X 是完整类型
	   arrp++;
	}
	```
7. [*Note: 声明和表达式的规则，在不完整类型的上下文环境中是被禁止的。*]
8. 一个对象类型（可能被`cv-qualified`修饰）是函数类型，引用类型和`cv void`之外的类型。
9. 数算类型，枚举类型，指针类型，指向成员的指针类型，`polar::nullptr_t`和这些类型的`cv-qualified`修饰的版本叫做标量类型（`scalar types`）。没有被`scalar types`修饰的标量类型，可平凡复制的类类型，或者这种类型的数组类型和这些类型的`cv-qualified`修饰的版本叫做平凡可复制的类型（`trivially copyable types`）。标量类型，平凡可复制类类型，或者这些类型的数组类型和这些类型的`cv-qualified`修饰的版本叫做平凡类型（`trivial types`）。标量类型和标准布局的类类型，这些类型的数组类型和这些类型`cv-qualified`修饰的版本被放在一起叫做标准布局类型（`standard-layout types`）。
10. 如果类型具备以下的条件中的一条被称作字面类型（`literal type`）:
	1. 一个`cv-qualified void`类型。
	2. 一个标量类型。
	3. 一个引用类型
	4. 一个字面类型的数组
	5. 一个具有下面所有属性的`cv-qualified`修饰的类类型：
		1. 具备一个平凡的析构函数
		2. 要么是一个闭包类型或者一个聚合类型或者至少具有一个`constexpr`修饰的构造函数或者模板构造函数并且不是复制构造函数和移动构造函数（可以通过继承从基类中得到）。
		3. 如果是一个联合类型，至少有一个非静态成员是非易变（`non-volatile`）的字面类型。
		4. 如果不是一个联合类型，那么类及其基类的所有的非静态数据成员都必须是非易变（`non-volatile`）的字面类型。
		[*Note: 字面类型是可能用来创建常量表达式，但是不保证一定能创建一个常量对象，也不保证其他那个字面类型的任何对象都能用在常量表达式中。*]
11. 两个类型一个是`cv1 T1`和`cv2 T2`满足`T1`和`T2`如果布局相容，那么他们相同的类型，或者布局相容的枚举类型或者布局相容标准布局的类类型。

## 基础类型

1. 被声明成字符类型的大小必须要能容纳基础字符集任何一个成员字符。如果一个基本字符集里面的字符存储在一个字符对象，这个字符对象的整形值等于这个字符的字面量的整数值。一个字符对象是否可以存放负数由编译器自己决定。字符可以被声明为`unsigned`或者`signed`。无格式的`char`，`signed char`和`unsigned char`是三个不一样的类型，统一叫做窄字符类型。`char`，`signed char`和`unsigned char`占用相同的存储空间并且有相同的对齐要求。也就是说他们具有相同的对象表示。对于窄字符类型，对象表示中的所有的位都参与对象的值表示。[*Note: 一个窄字符类型的位域，如果位域指定的大小大于相应的窄字符类型的对象表示位的位数大小时候，这个位域有填充位序列。*]对于无符号的窄字符类型，字符对象的值表示的任何一种组合都代表不一样的整数值。对于其他的数据类型来说可能没有这些要求。对于特定的编译器来说，无格式的`char`可能代表`signed char`或者`unsigned char`；具体采用那个是由编译器决定。在`unsigned char`类型表示的闭区间[0..255]其中的一个数值`i`，都存在一个`char`类型的`j`，`j`的值是用`i`转换成`char`类型得到的，并且得到值`j`转换成`unsigned char`又能得到`i`值。
2. 有五种标准有符号的整数类型：`signed char`，`short int`，`int`，`long int`和`long long int`。这个列表中，在后面的类型类型的存储空间至少是大于等于前一个。编译器可能提供扩展的有符号整数类型（`extended signed integer types`）。扩展的整形类型和标准的整形类型统称有符号的整数类型。无格式的`int`具有自然大小由当前执行环境确定。其他的有符号类型为了特殊的需求而提供的。
3. 对于每个标准的有符号整数类型都存在一个对应的但是不一样的无符号类型，叫做标准的无符号整数类型：`unsigned char`，`unsigned short int`，`unsigned int`，`unsigned long int`和`unsigned long long int`这个类型跟对应的整数类型所占的存储空间和对齐等要求保持一致。也就是说有符号的整形的跟无符号整形的对象表示是一致的。类似的扩展的有符号整形跟扩展的无符号整形有相同的存储空间要求和对齐要求。标准和扩展的无符号整形统称为无符号整形。有符号整形的正数部分的是其对应的无符号整形的子集。相同的值在两种整形类型中的表示是相同的，有符号整形和对应的无符号整形的值类型表示是一样的。标准的有符号整形跟标准的无符号整形统称为标准整形（`standard integer types`）。扩展的有符号整形和扩展的无符号整形统称为扩展整形（`extended integer types`）。有符号整形和无符号整形应该遵守`C`相关的规范。
4. 无符号整形的值应该遵守2<sup>n</sup>的取模运算，`n`是特性的整数的值表示的二进制的位数。
5. `wchar_t`是一个能够表示最大的扩展字符集的所有成员（支持本地化）。`wchar_t`跟其底层表示（`underlying type`）的整形具有相同的大小，符号和对齐要求。`char16_t`和`char32_t`依次跟类型`uint_least16_t`和`uint_least32_t`具有相同的大小，符号和对齐要求。相对应的定义在模块中`cstdint`，叫做底层类型。
6. `boolean`类型的值要么是`false`要么是`true`。[*Note: 没有signed，unsigned，short 或者 long 类型的 boolean 类型或者相关值。*]`boolean`类型的值参与整形提升转换。
7. `bool`，`char`，`char16_t`，`char32_t`和`wchar_t`，有符号整形和无符号整形统`integral types`。`integral`类型的值应该使用原生的二进制位进行定义。[*Note: 本规范整允许`two’scomplement`，`ones’ complement`和`signed magnitude`表示法。*]
8. 有三种浮点类型：`float`，`double`和`long double`。`double`类型的精度至少大于等于`float`，`long double`的精度至少大于等于`double`。`float`浮点数能够表示的值的集合是`double`浮点数能表示的集合的子集。`double`能表示的值的集合是`long double`能表示的集合的子集。浮点数的值表示形式由编译器自行决定。[*Note: 本规范中没有规定浮点操作室的精度。*]整形和浮点型统称为算数类型（`arithmetic types`）。标准库中的`polar::numeric_limits`应该指定所有算数类型的最大值和最小值。
9. `cv void`是一个不完整类型并且也不能变完整；这样的类型的值域为空。这个类型用在那些返回值为空的函数返回值类型定义。`cv void`表达式只能用在表达式语句中。作为一个逗号表达式的操作数，或者三元运算符`?:`的第二个或者第三个操作数。或者作为`typeid`，`noexcept`或者`decltype`的操作数。当做一个表达式用在`return`语句中，为那些返回值类型为`cv void`的函数提供返回值。用在一个显式类型转换中。
10. `polar::nullptr_t`类型的值是一个空指针常量。这样的值参与指针或者成员指针的转换。sizeof(polar::nullptr_t)应该跟sizeof(void *)大小一致。
11. [*Note: 即使编译器定义的两个或者多个类型具有相同的值表示，他们毫无悬念也是属于不同类型。*]

## 复合类型

1. 复合类型可以使用下面的方法进行构造：
	1. 给定对象类型的数组类型。
	2. 一个形参的类型是给定的类型并且返回值是`void`或者是给定类型的引用或者是给定类型的对象的函数类型。
	3. 指向给定类型的`cv-void`或者对象或者函数（包括静态成员函数）的指针。
	4. 给定类型的对象或者函数的引用，这里有两种类型的引用：
		1. 左值引用
		2. 右值引用
	5. 一个包含不同类型的子对象序列或者一个类型的集合或者枚举类型和操作这些对象的函数和一些访问这些实体的权限控制的类类型。
	6. 联合体，在不同的时间包含不同类型的对象的类型。
	7. 枚举类型，包含一个命名常量的集合，每个枚举项代表的一个不同的`enumerated type`。
	8. 指向类非静态数据成员的指针。其标识了一个给定类类型的对象里面成员。指向数据成员的指针和指向函数成员的指针统一叫做指向成员的指针类型。
2. 这些构造类型的方法可以递归使用，限制在章节`11.3.1`，`11.3.4`，`11.3.5`和`11.3.2`进行说明。如果构造出来的符合类型的对象的表示的字节数超过了`polar::size_t`的最大值，程序是不符合规范的。
3. 指向`cv void`的指针类型或者指向对象类型的指针类型叫做对象指针类型（`object pointer type`）。[*Note：指向`void`的指针不是对象指针类型，因为`void`类型不是对象类型。*]一个指定函数的指针类型叫做函数指针类型。一个指向类型`T`的对象的指针类型叫做指向类型的指针。[*Note: 指向`int`对象类型的指针叫做指向`int`指针。指向类型为`X`的对象的指针叫做指向`X`的指针。*]除了指向静态成员的指针，这个字面上的指针没有作用到指向成员上。指针不完整类型的指针是允许的，尽管只能在很有限的情况下进行使用。所有的指针类型的值是下面情况的一种：
	1. 指向一个对象或者函数的指针。
	2. 指向一个对象存储空间后一个字节的指针。
	3. 一个空指针。
	4. 一个不合法的指针值。
	一个指针类型的值是指向特定类型的对象所占用的存储空间的第一个字节的地址或者存储空间结束后面的第一个字节的地址。[*Note: 一个类型的对象所占用的存储空间结束后面的一个字节是跟这个对象类型相关的存储空间区域。一个指针的值在它所指示的类型的对象所占用的存储空间的周期结束是变成非法值。*]为了指针算数和指针值的比较方便，一个指向一个`n`个元素的数组`x`所占用的存储空间结束之后第一个字节的地址值跟`x[n]`所代表的地址值是相等的。指针类型具体的值表示由编译器自行决定。指向布局相容的数据类型的指针具有相同的值表示和对齐要求。[*Note: 指向一个过度对齐的类型没有特殊的表示，但是相应的有效值由扩展的对齐要求进行限制。*]
4. 对象`a`和对象`b`是下面条件中的一种叫做指针互换：
	1. 它们是相同的对象。
	2. 一个对象是一个联合体对象，另一个是那个联合体对象的一个非静态成员对象。
	3. 一个是一个标准布局的类类型对象，另一个这个对象的第一个非静态的数据成员。或者如果一个对象没有非静态数据成员，另一个是这个对象的基类型的子对象。
	4. 存在一个对象`c`，对象`a`跟对象`c`指针互换并且对象`b`跟对象`c`指针互换。
	如果两个对象是指针互换的，那么他们的地址是一样的。可以是使用`reinterpret_cast`从指针`a`到指针`b`转换。[*Note: 数组的对象和数组第一个元素对象不是指针互换类型，尽管他们的地址值是一样的。*]
5. 一个指向`cv-qualified`或者`cv-unqualified`的`void`可以用来指向位置类型的对象。这种指针类型可以存储任何类型的指针类型。一个`cv void *`指针类型应该跟`cv char *`有相同的表示和一样的对齐要求。
