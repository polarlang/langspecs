# 作用域
## 声明区域和作用域
1. 一个名字在程序文本中被引入的特定区域叫做这个名字的声明区域（*declarative region*）,这个区域是这个引入的名字的最大有效范围，在这个区域中，我们可以使用非限定的名字取访问同一个实体。一般来说，对于所有特定名字来说，程序文本中的那些名字有效的非连续的部分，叫做这个名字的作用域。去确定一个声明的作用域的时候，我们往往先找出当前声明的可能作用域（*potential scope*）。一个声明的作用域与可能作用域是相等的，除非在可能的作用域里面出现了相同名字的声明。这个时候，里面名字的声明区域的可能作用域被外面的声明区域的可能作用域排除在外。
2. 下面是个简单的例子：

	```cpp
   int j = 24;
   int main()
   {
      int i = j, j;
      j = 42;
   }
	```
	标识符`j`在这里被声明两个并且被使用两次。第一个`j`的声明区域是整个例子程序，他的可能的作用域从它的声明开始到程序的结束，它的使用作用域得除去字符`,`和字符`}`之间的程序区域。第二个`j`的声明区域（在分号前面的`j`）是字符`{`和字符`}`之间的程序区域，它的可能作用域是除去`i`声明之前的程序区域，它的实际作用域跟可能的作用域的范围一致。
3. 一个名字被一个声明引入当前作用域中，作用域由声明语句中名字出现后的地方开始，除了`elaborated-type-specifier`和`using-directives`语句，他们修改了这一行为。
4. 在一个声明区域里面，给定一个声明的集合，每一个声明都使用了相同的非限定名字，则应该是下面情况之一：
	1. 他们所有都应该引用相同的程序实体，或者所有都引用函数或者函数模板。
	2. 只能有一个名字声明类或者枚举类型并且不能是`typedef`类型的名字，其他剩余的声明中的名字必须引用相同的变量，非静态数据类成员，特定的枚举类型的成员（enumerator），或者所有声明都引用函数和函数模板；在这种情况下，类的名字和枚举类型的名字被隐藏了。[*Note: 一个命名空间的名字和类模板的名字必须在其声明区域保持唯一*]
[*Note: 这些限制作用于名字引用的声明区域，这个区域可能跟声明语句所在的区域不一样。特别的说 `elaborated-type-specifiers`语句将在当前区域的闭包的命名空间里面引入一个名字声明（可能不可见）。这些限制将作用于那个命名空间。局部的`extern`语句将在当前的声明区域和当前声明区域的闭包中引入一个名字 (闭包中的名字可能不可见)，所以这些限制将作用于这两个区域。*]
5. 对于一个给定的声明区域`R`和在`R`之外的一个点`P`，`P`与`R`之间的区域是由`R`闭包且不是`P`的闭包的部分组成。
6. 名字查找规则在下面名字查找章节进行总结。

## 声明点

1. 一个名字的声明点（Point of declaration）是从它自己的完整声明符（complete declarator）开始到它的初始化器结束，如果有初始化器的话。除了下面说明（Note）的情况：
	
	```cpp
	unsigned char x = 12;
	{
	   unsigned char x = x;
	}
	// 这里第二个 x 用它自己进行初始化
	```
2. [*Note: 一个来自外面的作用域的一个名字将保持可见，直到这个名字的另一个声明点隐藏它。*]
	```cpp
	const int i = 2;
	{
	   int i[i];
	}
	// 在块作用域中定义一个具有两个元素的数组变量
	```
3. 通过`class-specifier`产生式声明的类或者类模板的声明点是在其`class-head`产生式产生的`identifier`或者`simple-template-id`（如果有的话）后面。一个由`enum-specifier`产生式推导的枚举类型的声明点从其`identifier`开始，一个别名或者模板别名从别名引用的`type-id`开始。
4. 一个没有选择构造函数的`using-declarator`的声明点是用器声明符后面开始。
5. 一个枚举符的声明点从它的枚举项定义完成（enumerator-definition）后开始。
	
	```cpp
	const int x = 12;
	{
	   enum {
	      x = x;
	   };
	}
	// 这里枚举项（enumerator）x 使用常量 x 的值进行初始化
	```
6. 在一个类成员的声明点之后，在类作用域中都可以通过成员名进行查找。
	[*Note: 当类还没有看到完成的定义时，这条规则也成立*]
	```cpp
	struct X
	{
	   enum E
	   {
	      z = 16;
	   };
	   int b[x::E::z]; // OK
	};
	```
7. 对于`elaborated-type-specifier`产生式的类声明的声明点由以下规则指定：
	1. 对于声明形式为：
		```cpp
		class-key attribute-specifier-seqopt identifier;
		```
		会在声明出现的作用域中引入一个名字叫做`identifier `的类类型，否则参考下面一条规则。
	2. 对于声明形式为：
		```cpp
		class-key identifier;
		```
		如果`elaborated-type-specifier`被用于`decl-specifier-seq`产生式或者被用于一个在命名空间的函数定义的`parameter-declaration-clause`产生式中，那么在声明出现的命名空间里面引入名字为`identifier`的类类型；否则`identifier`将在包含声明的最小命名空间或者块作用域引入。[*Note: 这些规则在模板领域同样适用*] [*Note: 其他形式的`elaborated-type-specifier`没有声明一个新的名字，因此必须引用一个存在的类型名*]