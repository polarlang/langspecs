# 名字查找

1. 当讨论特定的规则的时候，在当前上下文中，只要文法允许相关的名字，那么名字查找规则就会应用到相应的名字（包括`typedef`引入的名字，命名空间的名字和类类型的名字）上。名字查找将名字的用途与改名字的一系列声明进行关联。这些通过名字查找得到的某个特定名字的所有声明要么引用相同的程序实体，要么所有的声明都指示函数或者函数模板。在后面这种情况，所有该名字的声明形成了一个针对该名字的函数重载集合。函数重载的决议发生在名字查找成功完成之后。访问控制规则（`access rules`）在名字查找和函数重载决议（`unction overload resolution`），如果可应用的话，成功之后才进行检查。只有在名字查找，函数重载决议和访问控制检查都成功之后，被名字声明引入的属性才会被处理。
2. 一个名字的在一个表达式上下文中进行名字查找是指在表达式所在的作用域中进行该名字的非限定名字查找的过程。
3. 一个类注入名字（`injected-class-name`），是一个类为了实现名字隐藏和名字查找而引入的一种类成员名字。

## 非限定名字的查找

1. 在本节列举的所有情况，当为一个名字查找合适的声明的时候，按照各自的分类所列举的顺序对作用域进行查找。在查找的过程中，只要找到合适的声明，整个查找过程结束，如果没有找到合适的声明，那么程序是不符合规范的。
2. 通过`using-directive`语句引入的名字声明，在`using-directive`语句所在的命名空间可见。在进行本节描述的非限定名字查找的时候，由`using-directive`语句引入的名字声明，将按照其所在的命名空间名字声明参与查找。
3. 当一个非限定的名字用在一个函数调用的后缀表达式里面的时候，将使用下面章节的*实参依赖名字查找*规则进行名字查找。在某些情况下当进行名字查找的时候，一个名字后面跟一个`<`字符，就算名字查找没有发现一个`template-name`，该名字也会被当成一个`template-name`。
	
	例子说明：
	
	```cpp
	int h;
	void g();
	namespace N
	{
	   struct A {};
	   template <class T> int f(T);
	   template <class T> int g(T);
	   template <class T> int h(T);
	}
	int x = f<N::A>(N::A()); // f 名字查找没有找到任何声明，应用参数依赖查找，找到 f 函数模板
	int y = g<N::A>(N::A()); // g 名字查找找到了 void g() 不匹配，应用参数依赖查找，找到 g 函数模板
	int z = h<N::A>(N::A()); // 找到名字 h，h< 不开始一个 template-id，查找失败
	```
	在一个表达式语法解释时候，参数依赖名字查找没有效果。
	
	例子说明：
	
	```cpp
	typedef int f;
	namespace N
	{
	   struct A
	   {
	      friend void f(A &);
	      operator int();
	      void g(A a) {
	         int i = f(a); // 这里的 f 是 typedef 的别名，可能别名先应用，而不是友元函数，等价于 int(a)
	      }
	   };
	}
	```
   在这里这个表达式因为不是一个函数调用，所有参数依赖查找过程不会应用，所有友元函数没有被查找到。
4. 一个在任何函数和类和用户自定义命名空间之外的全局命名空间里面使用的名字，必须在全局命名空间中其使用点之前进行声明。
5. 在用户自定义的命名空间中，一个在任何函数和类之外使用的名字，必须在该命名空间中且名字使用点之前进行声明，或者该命名空间中且名字使用点之前的闭包命名空间中进行声明。
6. 在命名空间的一个函数定义时，在函数`declarator-id`之后出现的名字查找过程如下。在函数体中其所在的代码块中使用点之前应该有其声明，否在上层块中进行查找直到函数体的最上层代码块，否则在命名空间`N`中其使用点之前应该声明，如果`N`是一个嵌套命名空间，则在`N`的闭包命名空间，名字使用点之前应该声明，重复这个过程直到全局命名空间，如果还是没有发现该名字的声明，那么程序是不符合规范的。
	
	例子说明：
	
	```cpp
	namespace A
	{
	   namespace N
	   {
	      void f();
	   }
	}
	
	void A::N::f()
	{
	   i = 5;
	   // 名字 i 的名字查找过程如下：
	   // 函数 f 最外层块且在 i 使用之前的区域
	   // 命名空间 N 且在名字使用之前的区域
	   // 命名空间 A 且在名字使用之前的区域
	   // 全局命名空间，且在函数定义 A::N::f() 之前的区域
	}
	```
7. 一个在类 `X` 定义之内且在任何成员函数体，默认参数定义，异常指示符（`noexcept-specifier`），嵌套类和默认成员初始化器之外的区域使用的名字，使用一下规则进行名字查找：
	1. 在其使用点之前的类`X`定义体重进行声明，或者是当前类`X`的基类中的一个类成员
	2. 如果类`X`是类`Y`的一个嵌套类，在类`Y`中，类`X`定义之前应该进行声明，或者该名字应该是类`Y`的基类的一个成员的声明。（这个过程依次应用与类`Y`的闭包类，从最里层的闭包类开始）
	3. 如果类`X`是一个局部类，或者是一个局部类的嵌套类，在类`X`所在程序块之内在类`X`的定义之前应该对名字进行声明。
	4. 如果`X`是命名空间`N`的一个成员或者是命名空间中的成员类中的一个嵌套类或者是一个局部类或者是一个命名空间`N`中的函数成员中的一个局部类的一个嵌套类，那么在命名空间`N`中，在`X`使用之前或者在`N`的闭包命名空间里面应该有该名字的声明。
	
	例子说明：
	
	```cpp
	namespace M
	{
	   class B {};
	}
	
	namespace N
	{
	   class Y extend M::B
	   {
	      class X
	      {
	         int a[i];
	      }
	   }
	}
	
	// 对于 名字 i 如下的作用域将被依次查找
	// 类作用域 N::Y::X 中，在 i 的使用之前
	// 类作用域 N::Y 在 N::Y::X 定义之前
	// 类作用域 N::B
	// 命名空间 N 中，类 N::Y 定义之前
	// 全局命名空间中，命名空间 N 定义之前
 	```
8. 对于类`X`的成员，一个用在在成员函数定义语句`declarator-id`之后的函数体，默认参数，异常指示符（`noexcept-specifier`），默认成员初始化器中的名字，需要按照下面的要求进行声明，条目之前是或的关系：
	1. 在名字所在的代码且在名字使用点之前进行声明，或者在其所在代码的闭包代码块且当前代码之前进行声明。
	2. 名字应该是类`X`的成员获取类`X`基类的成员。
	3. 如果`X`是类`Y`的嵌套类成员，那么名字应该是`Y`的成员，或者是类`Y`的基类的成员。（重复运用这个查询规则到类`Y`的闭包类，从最里层的闭包类开始）
	4. 如果`X`是局部类，或者是局部类的一个嵌套类，那么在类`X`定义的代码块且在类`X`定义之前进行声明。
	5. 如果`X`是命名空间的成员或者是一个命名空间`N`的成员类的嵌套类或者是一个局部类或者是命名空间`N`的成员函数的函数体代码块中的一个局部类的嵌套类，那么在命名空间`N`中且名字使用之前或者命名空间的闭包命名空间且在当前命名空间定义之前需要声明。

	例子说明：
	
	```cpp
	class B {};
	namespace M
	{
	   namespace N
	   {
	      class X extend B
	      {
	         void f();
	      }
	   }
	}
	
	void M::N::X::f()
	{
	   i = 16;
	}
	// 查找名字 i 时候，会依次搜索下面的命名空间
	// 搜索 函数 M::N::X::f 最外层代码块且在 i 使用之前
	// 搜索 类 M::N::X 的成员
	// 搜索 类 ::B 中的成员
	// 搜索 命名空间 M::N
	// 搜索 命名空间 M
	// 搜索 全局命名空间，在函数 M::N::X::f
	```

9. 在类中定义的`inline`友元函数定义中使用的名字的查找规则跟普通的类中的成员函数的规则是一样的。不在类中定义的友元函数中使用的名字，查找规则跟普通的命名空间的函数成员的查找规则一样。
10. 当使用友元的方式授权一个类成员访问权限时候，在查找一个在函数声明符里面且不再模板形参列表中使用的名字时候，会首先查找被授权的成员函数所在的类的作用域，如果不在或者名字是在模板形参列表中使用的时候，使用非限定名字在友元声明时候的查找方式进行查找，具体见规则9。
	
	例子说明：
	
	```cpp
	class A
	{
	   typedef int AT;
	   void f1(AT);
	   void f2(float);
	   template <typename T> void f3();
	};
	
	class B
	{
	   typedef char AT;
	   typedef float BT;
	   friend void A::f1(AT); // 在所在的类A作用域中找，AT类型是 A::AT 
	   friend void A::f2(BT); // 先在类A作用找，没找到，然后再 B 中找，BT的类型是B::BT
	   friend void A::f3<AT>(); // 用在模板形参列表中，AT 的类型是 B::AT
	};
	```
11. 当进行函数的默认参数或者类的构造函数的初始化序列中的名字查找时候，函数形参的名字会隐藏当前代码库，类或者包含函数定义的命名空间里面的名字声明。
12. 在进行枚举项定义（`enumerator-definition`）的常量表达式（`constant-expression`）中的名字查找时，在之前定义的枚举项的名字会隐藏当前代码块，类或者包含`enum-specifier`的命名空间里面的名字。
13. 在静态数据成员定义中且在`qualified-id`之后的名字查找，跟在静态成员函数中出现的名字的查找规则一样。
14. 如果一个命名空间的成员的定义出现在命名空间外面的时候，任何在那个定义中使用的名字的查找规则跟该定义出现在命名空间里面时一样。
	
	例子说明：
	
	```cpp
	namespace N
	{
	   int i = 4;
	   extern int j;
	}
	
	int i = 2;
	int N::j = i; // N::j == 4
	```
15. 在函数的`function-try-block`的处理器块使用的名字的超早规则，跟这个名字在函数最外层块中使用一样，函数的形参的名字不能在`exception-declaration`和`function-try-block`的处理器的最外层块进行重新绑定。在`function-try-block`处理块作用域中的名字查找时，将会忽略函数定义的最外层块，但是函数的形参不忽略。[*todo: 需要好好研究，这个地方有点意思*]

## 实参依赖名字查找