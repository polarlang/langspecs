# 内存和对象
## 内存模型
1. 在极语言的内存模型中最基础的存储单元是字节`byte`。一个`byte`的大小至少要能容纳任何在执行字符集里面的字符成员和UTF8编码规范的八比特的编码单元并且由连续的比特序列组成，比特序列的长度由极语言编译器决定。最不重要的比特（`least significant bit`）叫做`low-order bit`；最重要的比特叫做`high-order bit`，系统提供给极语言的内存是由一个或者多个字节序列组成的。没有个字节都有一个唯一的地址。
2. 一个内存位置是一个标量类型的对象或者由相邻的长度不为零的比特位域的最长序列。[*Note: 语言的各种特性，比如引用或者虚函数，可能使用一些程序员不可见但是由编译器进行管理的内存位置。*]两个或者多个运行的线程同时访问不同的内存位置不会相互干扰。
3. [*Note: 一个位域和其相邻的非位域字段是在不同的内存位置，因此可以被两个或者多个线程同时访问而不会相互干扰。这个规则对两个位域其中一个定义在嵌套的结构体而另一个不是的情况或者两个位域之间被长度为零的位域隔开，或者被不是位域的字段隔开。同时更新结构体中两个中间都是长度不为零的位域是不安全的。*]
	
	例子说明
	
	```cpp
	struct 
	{
	  char a;
	  int b: 5,
	  c: 11,
	  :0,
	  d: 8,
	  strcut { int ee: 8} e;
	}
	```
	以上代码含有四个内存位置成员a，位域d，位域e.ee是不同的内存位置，可以同时进行修改而不会相互影响。位域b和位域c是第四个内存位置，它两不能同时进行修改，但是成员a和位域b可以同时进行修改。

## 对象模型

1. 在极语言中对对象有创建，销毁，引用，访问和操作等活动。对象的创建按照定义，通过`new-expression`创建，当隐式的改变联合体当前活动成员的时候或者当一个临时对象被创建。在对象被创建到其整个生命周期，直到最后被销毁，占用一段区域的存储空间。[*Note: 函数不是对象，尽管可能函数也会像对象那样占用一定的存储空间。*][*todo: 函数不是`first class`类型？*]对象的属性在对象创建之后进行检查。一个对象可以有名字。一个对象可以有存储周期，并会影响对象的生命周期。一个对象具有类型。一些对象是多态的，由编译器负责生成一些跟这些多态类相关的信息，在运行时能够判断对象的类型。对于其他类型的对象的值，通过访问它的`expressions`的类型来决定。
2. 对象可以包含其他的对象，叫做子对象`subobjects`。一个子对象可以是成员子对象（`member subobject`），也可以是基类子对象（`base class subobject`）或者一个数组的元素子对象。一个不是其他任何对象的子对象的对象称作一个完整的对象（`complete object`）。一个对象在成员对象或者数组元素`e`所在的存储区域创建的时候，新创建的对象是`e`的所属对象的子对象的话，需要同属满足下面的条件：
	1. `e`的宿主对象的作用域已经开始，但是还没有结束。
	2. 新创建的对象的存储空间正好覆盖了`e`所关联的存储空间。
	3. 新创建的对象的类型跟`e`的类型一样。(忽略cv-qualification）
	
	[*Note: 如果新的子对象中包含有引用成员或者常量子对象成员，原来对象的名字不能用来访问新创建的对象。*]
	
	例子说明：
	
	```cpp
	class X
	{
	   const int n;
	};
	
	union U
	{
	   X x;
	   float f;
	};
	
	void tong()
	{
	   U u = {{ 1 }};
	   u.f = 5.0f; // OK 创建一个 u 的子对象
	   X *p = new (&u.x) X {2}; // OK 创建一个 u 的子对象
	   assert(p->n == 2); // OK
	   assert(*polar::lanuder(&u.x.n) == 2); // OK
	   assert(u.x.n == 2); // 为定义行为，不能通过 u.x 对创建的新对象进行访问
	}
	```
3. 如果一个完整的对象在一个类型`e`为`array of N unsigned char`的对象或者为`array of N polar::byte`的对象所关联的对象上创建，当同时满足下面的条件时数组将为新创建的对象提供存储空间：
	1. `e`的生命周期已经开始并且还没有结束。
	2. 新创建的对象的存储空间符合`e`所关联的存储空间的大小。
	3. 没有更小的数组对象满足这些限制。
	[*Note: 如果数组的存储空间被一个对象占用，那么那个对象的生命周期结束，因为它的存储空间被重新使用了。*]
	
	例子说明：
	
	```cpp
	template<typename ...T>
	struct AlignedUnion
	{
	   alignas(T...) unsigned char data[max(sizeof(T)...)];
	};
	
	int f()
	{
	   AlignedUnion<int, char> au;
	   int *p = new (au.data) int; // OK, au.data provides storage
	   char *c = new (au.data) char(); // OK, ends lifetime of *p
	   char *d = new (au.data + 1) char();
	   return *c + *d; // OK
	}
	
	struct A { unsigned char a[32]; };
	struct B { unsigned char b[16]; };
	A a;
	B *b = new (a.a + 8) B; // a.a 提供存储空间给 *b
	int *p = new (b->b + 4) int; // b->b 提供存储空间给 *p
	                             // a.a 没有直接提供存储空间给 *p
	                             // 但是 *p 嵌套在 a 中
	```
4. 当满足下面任何一条时候，我们就说对象`a`嵌套在（`nested within`）对象`b`中：
	1. 对象`a`是对象`b`的子对象。
	2. 对象`b`给对象`a`提供存储空间。
	3. 存在一个对象`c`，对象`a`嵌套在对象`c`里面，对象`c`嵌套在对象`a`里面。
5. 对于任何对象`x`，都存在某个对象叫做对象`x`的完整对象。判断条件如下：
	1. 如果`x`是完整对象，那么`x`的完整对象是它自己。
	2. 否则，`x`的完整对象是唯一包含对象`x`的完整对象。
6. 如果一个完整对象，一个数据成员或者一个数组元素是一个类类型，他们的类型被称作`most derived class`，用来这个类类型与其基类的子对象。一个`most derived class`或者非类类型的对象叫做`most derived object`。
7. 除非是位域，一个`most derived object`应该占用一个或者多个字节的存储空间。基类子对象可能不占用存储空间。一个含有平凡复制能力（`trivially copyable`）或者标准内存布局（`standard-layout`）类型的对象应该占用连续的字节序列的存储空间。
8. 除非是位域或者是大小为零的基类子对象，对象的地址是其占用的存储空间的首字节的地址。一个生命周期相互覆盖的两个非位域的两个对象，如果一个嵌套在另一个里面或者至少一个是大小为零的基类子对象并且两个对象的类型不一样，这两个对象的地址可能一样，否则他们具有不同的地址。
	
	例子说明：
	
	```cpp
	static const char test1 = ’x’;
	static const char test2 = ’x’;
	const bool b = &test1 != &test2; // 永远为 true
	```
9. [*Note: 极语言提供一些最基本的类型定义和几种从现有基础类型合成新类型的机制。*]

## 对象生命周期

1. 对象或者引用的生命周期是对象或者引用的运行时属性。一个对象如果是一个类类型或者聚合类型并且它自己或者它的一个子对象被一个非平凡的构造函数初始化，那么我们说这个对象具备有意义的初始化（`non-vacuous initialization`）[*Note: 被平凡的复制或者移动构造函数初始化也是一个具备意义的初始化。*]，当下面的条件全部满足的时候，类型`T`的对象的生命周期开始：
	1. `T`的存储空间被合理的进行了对齐并且类型`T`的大小已经被获取。
	2. 如果`T`的对象具有有意义的初始化，它的初始化已经完成。
	除了下面这种情况，如果对象是一个联合体的成员或者子对象，它的生命周期只有当前在联合体中已经初始化完成之后才开始。
2. 当下面的情况中一种发生时，对象的作用域结束：
	1. 如果类型`T`是一个具有非平凡的析构函数的类类型，它的析构函数开始调用。
	2. 对象占用的存储空间被释放或者被一个不是对象`o`的嵌套对象所占用。
3. 一个引用的生命周期开始于他被初始化，然后跟标量数据类型的对象一样的方式结束。
4. 在本文档中归于对象或者引用的属性只在其声明周期里面进行应用。[*Note: 在一个对象的声明周期开始之前或者结束之后去使用一个对象的时候需要特别注意，同样的一个正在构造中的对象和一个正在被析构的对象的使用也跟正在生命周期已经开始且没有结束中的对象有很大的区别。*]
5. 一个程序可能通过重新利用一个对象的存储空间的方式来终止任何一个对象的生命周期或者通过调用一个类类型的非平凡的析构函数来终止。对应一个具有非平凡的构造函数的类类型，当它所占用的存储空间被重新利用或者被释放，不要求程序显式的对其析构函数进行调用。然后如果一个程序没有显示的调用析构函数或者没有用`delete-expression`去释放占用的空间，析构函数不能隐式的被调用并且任何依赖析构函数副作用的行为都是未定义的。