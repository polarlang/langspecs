# 唯一定义原则

1. 任何一个转换单元里面的任何变量，函数，类类型，枚举类型和模板类型都只能存在一个定义。
2. 除了不求值操作数（unevaluated operand）和子表达式之外的表达式都是可能求值（potentially evaluated）的表达式。一个表达式`expr`可能的结果 *`potential results`* 定义如下：
	1. 如果`expr`是一个`id-expression`，那么值的集合只包含`expr`本身。
	2. 如果`expr`是一个数组操作数下标操作表达式，那么值的集合包含数组操作数可能的值。
	3. 如果`expr`是一个类成员访问表达式，那么值的集合包含对象成员访问表达式所有可能的值。
	4. 如果`expr`是一个指向类成员的指针并且第二个操作室是一个常量表达式，那么值的集合是对象成员访问表达式所有可能的值。
	5. 如果`expr`是一个形式为`(expr1)`的表达式，那么值的集合为`expr1`的值。
	6. 如果`expr`是一个`gvalue`值类型的条件表达式[*例如：`condexpr ? true-expr: false-expr;`*]，那么值的集合是第二个操作数和第三个操作数的值的联合。
	7. 如果`expr`是一个逗号表达式，那么值的集合是最右边操作数的值。
	8. 其他情况下，值集合为空。
	
	```cpp
	// 下面的例子中，n 的初始化表达式的结果是第一个 S::x 不是第二个 S::x
	struct S
	{
      static const int x = 0;
	};
	const int &f(const int &r);
	int n = b ? (1, S::x) // 这里 S::x 没有应用单一定义原则
	          : f(S::x) // 这里应用了单一定义原则，所以在这里需要看见 S 的完整定义
	```
	