# 数据类型

1. [在本节中，我们在忽略类型的具体表示的情况下给类型添加要求。极语言中有两种类型，基本类型和符合类型，类型是用来描述对象，引用或者函数。]
2. 对于任何一个非基类的可平凡复制的对象类型`T`，不管当前的对象里是否存有类型`T`合法的数据，组成类型`T`的对象的底层字节数据可以复制到`char`，`unsigned char`或者`polar::byte`类型的数组中。如果再把数组中的值复制会原来的对象存储空间里后，原来的对象的值不变。

	例子说明：
	```cpp
	constexpr const polar::size_t N = sizeof(T);
	char buf[N];
	T obj; // 对象 obj 初始化原始值
	polar::memcpy(buf, &obj, N); // 将对象中的数据复制到数组中,在这两次复制中，原来的对象的值可能会被改变
	polar::memcpy(&obj, buf, N); // 所有对象的标量成员都具有原来的值
	```
3. 对于任何可平凡复制的类型`T`，两个类型`T`的指针指向不同的两个对象`obj1`和`obj2`，这两个对象都不是基类类型。如果把对象`obj1`的底层字节复制到对象`obj2`的存储空间中，那么`obj1`和`obj2`具有同样的值。
	
	例子说明：
	
	```cpp
	T *t1p;
	T *t2p;
	polar::memcpy(t1p, t2p, sizeof(T));// t1p 指针引用的对象的值跟 t2p 指针引用的值一样
	```
4. 类型`T`的对象表示`object representation`是组成类型`T`的对象的`N`个`unsigned char`对象的组成的序列，`N`的大小是`sizeof(T)`。一个对象的值表示（`value representation`）是表示类型`T`的对象值的位序列。在对象表示中那些不表示值的位叫做填充位序列。在可平凡复制的对象中，对象的值表示是那些决定对象值的位序列的集合，是一个由编译器定义的离散元素的值集合。
5. 一个被声明了但是没有被定义的类类型，一个在特定上下文中的枚举类型，一个没指定长度的数组或者不完整元素类型叫做不完整定义的对象类型（`incompletely-defined object type`），不完整的对象类型和`cv void`统称不完成类型（`incomplete types`）。一个对象不能定义为不完整类型。
6. 一个类类型（比如类`X`）可能在转换单元的某个点是不完整类型，在后面的某个点又变成完整类型。在两个点类`X`具有相同的类型。当声明一个数组的时候，数组的元素的类型可以是不完整的类类型，这样的数组叫做不完整的数组。如果在转换单元后面某个点，数组元素类型变成完全类型，在这两个点上，两个数组的类型是一样的。一个数组可以不定义长度，那么它在转换单元中的某点是不完整的，但是在后面的某点可能是完整的。在这两个点数组的类型是不一样的。（一个是未知长度的数组，另一个是长度为`N`的数组）指向数组的指针是不知道数组的长度的。或者一个未知长度`typedef`名字的声明，是不能变完整的。

	例子说明：
	```cpp
	class X; // X 是不完整类型
	extern X *xp; // 是一个指向不完整类型的指针
	extern int arr[]; // 数组类型 arr 是不完整的类型
	typedef int UNKA[]; // UNKA 数组是不完整类型
	UNKA *arrp; // arrp 是指向不完整类型的指针
	UNKA **arrpp;
	
	void foo()
	{
	   xp++; // 编译错误，X 是不完整类型
	   arrp++; // 编译错误
	   arrpp++; // OK UNKA* 的大小是知道的
	}
	
	class X { int i; }; // X 到这里是完整的值
	int arr[10]; // 数组 arr 现在是完整的类型
	
	X x;
	void bar()
	{
	   xp = &x; // OK xp 是 X 类型的指针
	   arrp = &arr; // 编译错误，类型不一致
	   xp++; // OK X 是完整类型
	   arrp++;
	}
	```
7. [*Note: 声明和表达式的规则，在不完整类型的上下文环境中是被禁止的。*]
8. 一个对象类型（可能被`cv-qualified`修饰）是函数类型，引用类型和`cv void`之外的类型。
9. 数算类型，枚举类型，指针类型，指向成员的指针类型，`polar::nullptr_t`和这些类型的`cv-qualified`修饰的版本叫做标量类型（`scalar types`）。没有被`scalar types`修饰的标量类型，可平凡复制的类类型，或者这种类型的数组类型和这些类型的`cv-qualified`修饰的版本叫做平凡可复制的类型（`trivially copyable types`）。标量类型，平凡可复制类类型，或者这些类型的数组类型和这些类型的`cv-qualified`修饰的版本叫做平凡类型（`trivial types`）。标量类型和标准布局的类类型，这些类型的数组类型和这些类型`cv-qualified`修饰的版本被放在一起叫做标准布局类型（`standard-layout types`）。
10. 如果类型具备以下的条件中的一条被称作字面类型（`literal type`）:
	1. 一个`cv-qualified void`类型。
	2. 一个标量类型。
	3. 一个引用类型
	4. 一个字面类型的数组
	5. 一个具有下面所有属性的`cv-qualified`修饰的类类型：
		1. 具备一个平凡的析构函数
		2. 要么是一个闭包类型或者一个聚合类型或者至少具有一个`constexpr`修饰的构造函数或者模板构造函数并且不是复制构造函数和移动构造函数（可以通过继承从基类中得到）。
		3. 如果是一个联合类型，至少有一个非静态成员是非易变（`non-volatile`）的字面类型。
		4. 如果不是一个联合类型，那么类及其基类的所有的非静态数据成员都必须是非易变（`non-volatile`）的字面类型。
		[*Note: 字面类型是可能用来创建常量表达式，但是不保证一定能创建一个常量对象，也不保证其他那个字面类型的任何对象都能用在常量表达式中。*]
11. 两个类型一个是`cv1 T1`和`cv2 T2`满足`T1`和`T2`如果布局相容，那么他们相同的类型，或者布局相容的枚举类型或者布局相容标准布局的类类型。